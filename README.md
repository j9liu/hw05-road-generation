# Road Generation
**By Janine Liu / jliu99**

# External Resources

In addition to the class lectures and powerpoints, I consulted a few external resources for this project:
- https://stackoverflow.com/questions/41855261/calculate-the-angle-between-a-line-and-x-axis, for the formula for calculating the angle between a given line and the x-axis.
- https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect, for a method of checking whether two line segments intersect or not.
- https://webglfundamentals.org/webgl/lessons/webgl-render-to-texture.html, for how to convert a rendered image into a texture in WebGL.

# Live GitHub demo
https://j9liu.github.io/roadgen/

# Road Representation

The tweakable, self-sensitive nature of the road network demands that the roads be stored as mutatable data before they are committed to visualized objects. Here, roads are represented as instances of an `Edge` class; defined by two points, an `Edge` can perform various calculations on itself, such as calculating its length and midpoint, and with other `Edge` instances, such as checking for intersections with another `Edge`. Intersections between two or more `Edge` instances are marked by a `Node`, which functions mainly as a marker for an intersection.

# Road Generator Set-Up

The road data is generated by an instance of a class appropriately named `RoadGenerator`. For this class to generate roads, it first defines the two-dimensional space in which the data exists, called "cityspace." The bounds of cityspace are defined from (0, 0) in the bottom left corner to a specified (length, length) in the upper right corner. Our generator operates within the coordinates of this cityspace to produce roads and intersections (as represented by `Edge`s and `Node`s); their positions will then be transformed from cityspace to the space on the actual screen.

The generator also operates on a grid-cell system for storing relevant information about the nodes' whereabouts. `Node`s are stored based on what cell they fall into, while `Edge`s are stored in the cells they intersect. (The `Edge`s are also stored in a separate array so they can be more easily exported for rendering.) In order to reduce the amount of time it takes to check if a road intersects another road, we use this system to sort nodes and edges into cells that divides the cityspace into a grid as shown.

![](grid.png)

Since calculating the cell that contains a point only requires arithmetic, retrieving the cell that contains any position in the city space is straightforward. Using the grid system limits how much time is spent searching for an `Edge` or `Node` compared to a pure list, which might need to be iterated through completely. This setup is also why `Edge` instances are not defined by two `Node` instances; although they initially were, it resulted in the same information being stored twice for no real benefit. Therefore, `Node` instances only mark the intersections of two or more `Edge` instances.

# Pseudo L-System Constraints

I adapted the L-System framework from my [previous project](https://j9liu.github.io/plant/) as a basis for the road generation. There are no strings and expansion rules involved, but the generator uses a stack of `Turtle` agents to help draw the roads on the screen. However, they determine whether or not to continue expanding (and in what directions) based on fixed conditions and goals for each road type.

**Highways**

The expansion procedure for highways mirrors the implementation in the [Procedural Modeling of Cities](proceduralCityGeneration.pdf) handout. From the current drawing `Turtle`'s position, multiple `Turtle` instances are marched along rays in a user-specified search radius, where each ray tests a new direction for potential expansion. Each ray is assigned a weight, where the weight is the sum of samples of the population function along the ray divided by the samples' distance from the original point. Then, the direction with the largest weight is chosen for the current `Turtle` to draw along. If there is another direction that is compelling enough to continue expanding towards (according to the weight of it), and that direction is large enough of an angle away from the `Turtle`'s orientation, then 

**Grid-Specific Constrictions**
- (50% probability) Draw a grid that terminates early.

**General**

- **Water Level**: Given a new edge, the network checks if an edge terminates in the water and, if so, tries to either extend the road to an island (if it's a highway) or shorten the road to end on land If the resulting edge is too short, it is disregarded.

- **Self-Sensitivity**: Given a new edge, the network determines the closest intersection to the end of the edge; if it falls close enough to the edge (as defined by a chosen radius), the edge snaps to that intersection. The network then generates all intersections this new edge has with other edges in the network, provided they don't already exist. Finally, the closest new intersection is also managed so that if it occurs within a similar threshold, the end of the edge snaps to that new intersection.

# Road Visualization

The road generator creates its own projection matrix to transform the network cityspace coordinates (from (0, 0) and (width, height)) to screen coordinates (from (-1, -1) and (1, 1)), such that they can be displayed in the 2D view as shown.


# Data Generation and Aesthetic Features

The height map used is generated from an FBM noise function and looks as follows with a strictly land-water view. 

![](landwater.png)

For the more detailed elevation map, the heights were hardcoded to a color map where the lighter the color, the higher the height.

![](elevation.png)

The population density is generated from a combination of FBM noise and Worley noise, and was also manually color mapped as shown.

![](population.png)

It is possible to display both the elevation data and the population data at the same time, overlaid on top of one another.

![](elevationpopulation.png)